//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\phmarques\Documents\GitHub\NCalc2\NCalc2\NCalc2.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace NCalc2.Grammar {

using System;
using System.Text;
using System.Globalization;
using System.Collections.Generic;
using NCalc2.Expressions;
using ValueType = NCalc2.Expressions.ValueType;

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class NCalc2Parser : Parser {
	public const int
		T__29=1, T__28=2, T__27=3, T__26=4, T__25=5, T__24=6, T__23=7, T__22=8, 
		T__21=9, T__20=10, T__19=11, T__18=12, T__17=13, T__16=14, T__15=15, T__14=16, 
		T__13=17, T__12=18, T__11=19, T__10=20, T__9=21, T__8=22, T__7=23, T__6=24, 
		T__5=25, T__4=26, T__3=27, T__2=28, T__1=29, T__0=30, TRUE=31, FALSE=32, 
		NAME=33, INTEGER=34, DATETIME=35, VAR=36, E=37, FLOAT=38, STRING=39, WS=40;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'/'", "'!='", "'||'", "'>>'", "'<<'", "'&&'", "'='", "'^'", 
		"'?'", "'<='", "'&'", "'('", "'*'", "','", "':'", "'>='", "'<'", "'=='", 
		"'|'", "'~'", "'>'", "'or'", "'!'", "'<>'", "'%'", "')'", "'and'", "'+'", 
		"'not'", "'-'", "'true'", "'false'", "NAME", "INTEGER", "DATETIME", "VAR", 
		"E", "FLOAT", "STRING", "WS"
	};
	public const int
		RULE_ncalc = 0, RULE_expr = 1, RULE_orExpr = 2, RULE_andExpr = 3, RULE_bitOrExpr = 4, 
		RULE_bitXorExpr = 5, RULE_bitAndExpr = 6, RULE_eqExpr = 7, RULE_relExpr = 8, 
		RULE_shiftExpr = 9, RULE_addExpr = 10, RULE_multExpr = 11, RULE_unaryExpr = 12, 
		RULE_primaryExpr = 13, RULE_value = 14, RULE_id = 15;
	public static readonly string[] ruleNames = {
		"ncalc", "expr", "orExpr", "andExpr", "bitOrExpr", "bitXorExpr", "bitAndExpr", 
		"eqExpr", "relExpr", "shiftExpr", "addExpr", "multExpr", "unaryExpr", 
		"primaryExpr", "value", "id"
	};

	public override string GrammarFileName { get { return "NCalc2.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


	private const char BS = '\\';
	private static NumberFormatInfo numberFormatInfo = new NumberFormatInfo();

	private string extractString(string text) {
	    
	    StringBuilder sb = new StringBuilder(text);
	    int startIndex = 1; // Skip initial quote
	    int slashIndex = -1;

	    while ((slashIndex = sb.ToString().IndexOf(BS, startIndex)) != -1)
	    {
	        char escapeType = sb[slashIndex + 1];
	        switch (escapeType)
	        {
	            case 'u':
	              string hcode = String.Concat(sb[slashIndex+4], sb[slashIndex+5]);
	              string lcode = String.Concat(sb[slashIndex+2], sb[slashIndex+3]);
	              char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode, 16), System.Convert.ToByte(lcode, 16)} )[0];
	              sb.Remove(slashIndex, 6).Insert(slashIndex, unicodeChar); 
	              break;
	            case 'n': sb.Remove(slashIndex, 2).Insert(slashIndex, '\n'); break;
	            case 'r': sb.Remove(slashIndex, 2).Insert(slashIndex, '\r'); break;
	            case 't': sb.Remove(slashIndex, 2).Insert(slashIndex, '\t'); break;
	            case '\'': sb.Remove(slashIndex, 2).Insert(slashIndex, '\''); break;
	            case '\\': sb.Remove(slashIndex, 2).Insert(slashIndex, '\\'); break;
	            default: throw new Exception("Unvalid escape sequence: \\" + escapeType);
	        }

	        startIndex = slashIndex + 1;

	    }

	    sb.Remove(0, 1);
	    sb.Remove(sb.Length - 1, 1);

	    return sb.ToString();
	}

	public NCalc2Parser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class NcalcContext : ParserRuleContext {
		public LogicalExpression retValue;
		public ExprContext _expr;
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(NCalc2Parser.Eof, 0); }
		public NcalcContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ncalc; } }
	}

	[RuleVersion(0)]
	public NcalcContext ncalc() {
		NcalcContext _localctx = new NcalcContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_ncalc);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 32; _localctx._expr = expr();
			State = 33; Match(Eof);
			 _localctx.retValue =  _localctx._expr.retValue;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public OrExprContext first;
		public ExprContext middle;
		public ExprContext right;
		public OrExprContext _orExpr;
		public OrExprContext orExpr() {
			return GetRuleContext<OrExprContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_expr);
		try {
			State = 46;
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 36; _localctx.first = orExpr(0);
				State = 37; Match(T__21);
				State = 38; _localctx.middle = expr();
				State = 39; Match(T__15);
				State = 40; _localctx.right = expr();
				 _localctx.retValue =  new TernaryExpression(_localctx.first.retValue, _localctx.middle.retValue, _localctx.right.retValue);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 43; _localctx._orExpr = orExpr(0);
				 _localctx.retValue =  _localctx._orExpr.retValue;
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public OrExprContext first;
		public AndExprContext _andExpr;
		public OrExprContext orExpr() {
			return GetRuleContext<OrExprContext>(0);
		}
		public AndExprContext andExpr() {
			return GetRuleContext<AndExprContext>(0);
		}
		public OrExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orExpr; } }
	}

	[RuleVersion(0)]
	public OrExprContext orExpr() {
		return orExpr(0);
	}

	private OrExprContext orExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		OrExprContext _localctx = new OrExprContext(_ctx, _parentState);
		OrExprContext _prevctx = _localctx;
		int _startState = 4;
		EnterRecursionRule(_localctx, 4, RULE_orExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 49; _localctx._andExpr = andExpr(0);
			 _localctx.retValue =  _localctx._andExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 59;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,1,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new OrExprContext(_parentctx, _parentState);
					_localctx.first = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_orExpr);
					State = 52;
					if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
					State = 53;
					_la = _input.La(1);
					if ( !(_la==T__27 || _la==T__8) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					State = 54; _localctx._andExpr = andExpr(0);
					 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Or, _localctx.first.retValue, _localctx._andExpr.retValue);
					}
					} 
				}
				State = 61;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,1,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AndExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public AndExprContext first;
		public BitOrExprContext _bitOrExpr;
		public AndExprContext andExpr() {
			return GetRuleContext<AndExprContext>(0);
		}
		public BitOrExprContext bitOrExpr() {
			return GetRuleContext<BitOrExprContext>(0);
		}
		public AndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_andExpr; } }
	}

	[RuleVersion(0)]
	public AndExprContext andExpr() {
		return andExpr(0);
	}

	private AndExprContext andExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		AndExprContext _localctx = new AndExprContext(_ctx, _parentState);
		AndExprContext _prevctx = _localctx;
		int _startState = 6;
		EnterRecursionRule(_localctx, 6, RULE_andExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 63; _localctx._bitOrExpr = bitOrExpr(0);
			 _localctx.retValue =  _localctx._bitOrExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 73;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,2,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new AndExprContext(_parentctx, _parentState);
					_localctx.first = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_andExpr);
					State = 66;
					if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
					State = 67;
					_la = _input.La(1);
					if ( !(_la==T__24 || _la==T__3) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					State = 68; _localctx._bitOrExpr = bitOrExpr(0);
					 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.And, _localctx.first.retValue, _localctx._bitOrExpr.retValue);
					}
					} 
				}
				State = 75;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,2,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class BitOrExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public BitOrExprContext first;
		public BitXorExprContext _bitXorExpr;
		public BitOrExprContext bitOrExpr() {
			return GetRuleContext<BitOrExprContext>(0);
		}
		public BitXorExprContext bitXorExpr() {
			return GetRuleContext<BitXorExprContext>(0);
		}
		public BitOrExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitOrExpr; } }
	}

	[RuleVersion(0)]
	public BitOrExprContext bitOrExpr() {
		return bitOrExpr(0);
	}

	private BitOrExprContext bitOrExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		BitOrExprContext _localctx = new BitOrExprContext(_ctx, _parentState);
		BitOrExprContext _prevctx = _localctx;
		int _startState = 8;
		EnterRecursionRule(_localctx, 8, RULE_bitOrExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 77; _localctx._bitXorExpr = bitXorExpr(0);
			 _localctx.retValue =  _localctx._bitXorExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 87;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,3,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new BitOrExprContext(_parentctx, _parentState);
					_localctx.first = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_bitOrExpr);
					State = 80;
					if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
					State = 81; Match(T__11);
					State = 82; _localctx._bitXorExpr = bitXorExpr(0);
					 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.BitwiseOr, _localctx.first.retValue, _localctx._bitXorExpr.retValue);
					}
					} 
				}
				State = 89;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,3,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class BitXorExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public BitXorExprContext first;
		public BitAndExprContext _bitAndExpr;
		public BitAndExprContext bitAndExpr() {
			return GetRuleContext<BitAndExprContext>(0);
		}
		public BitXorExprContext bitXorExpr() {
			return GetRuleContext<BitXorExprContext>(0);
		}
		public BitXorExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitXorExpr; } }
	}

	[RuleVersion(0)]
	public BitXorExprContext bitXorExpr() {
		return bitXorExpr(0);
	}

	private BitXorExprContext bitXorExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		BitXorExprContext _localctx = new BitXorExprContext(_ctx, _parentState);
		BitXorExprContext _prevctx = _localctx;
		int _startState = 10;
		EnterRecursionRule(_localctx, 10, RULE_bitXorExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 91; _localctx._bitAndExpr = bitAndExpr(0);
			 _localctx.retValue =  _localctx._bitAndExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 101;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,4,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new BitXorExprContext(_parentctx, _parentState);
					_localctx.first = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_bitXorExpr);
					State = 94;
					if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
					State = 95; Match(T__22);
					State = 96; _localctx._bitAndExpr = bitAndExpr(0);
					 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.BitwiseXOr, _localctx.first.retValue, _localctx._bitAndExpr.retValue);
					}
					} 
				}
				State = 103;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,4,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class BitAndExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public BitAndExprContext first;
		public EqExprContext _eqExpr;
		public BitAndExprContext bitAndExpr() {
			return GetRuleContext<BitAndExprContext>(0);
		}
		public EqExprContext eqExpr() {
			return GetRuleContext<EqExprContext>(0);
		}
		public BitAndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitAndExpr; } }
	}

	[RuleVersion(0)]
	public BitAndExprContext bitAndExpr() {
		return bitAndExpr(0);
	}

	private BitAndExprContext bitAndExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		BitAndExprContext _localctx = new BitAndExprContext(_ctx, _parentState);
		BitAndExprContext _prevctx = _localctx;
		int _startState = 12;
		EnterRecursionRule(_localctx, 12, RULE_bitAndExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 105; _localctx._eqExpr = eqExpr(0);
			 _localctx.retValue =  _localctx._eqExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 115;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,5,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new BitAndExprContext(_parentctx, _parentState);
					_localctx.first = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_bitAndExpr);
					State = 108;
					if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
					State = 109; Match(T__19);
					State = 110; _localctx._eqExpr = eqExpr(0);
					 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.BitwiseAnd, _localctx.first.retValue, _localctx._eqExpr.retValue);
					}
					} 
				}
				State = 117;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,5,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class EqExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public EqExprContext first;
		public RelExprContext _relExpr;
		public RelExprContext relExpr() {
			return GetRuleContext<RelExprContext>(0);
		}
		public EqExprContext eqExpr() {
			return GetRuleContext<EqExprContext>(0);
		}
		public EqExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eqExpr; } }
	}

	[RuleVersion(0)]
	public EqExprContext eqExpr() {
		return eqExpr(0);
	}

	private EqExprContext eqExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		EqExprContext _localctx = new EqExprContext(_ctx, _parentState);
		EqExprContext _prevctx = _localctx;
		int _startState = 14;
		EnterRecursionRule(_localctx, 14, RULE_eqExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 119; _localctx._relExpr = relExpr(0);
			 _localctx.retValue =  _localctx._relExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 134;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 132;
					switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
					case 1:
						{
						_localctx = new EqExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_eqExpr);
						State = 122;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 123;
						_la = _input.La(1);
						if ( !(_la==T__23 || _la==T__12) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 124; _localctx._relExpr = relExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Equal, _localctx.first.retValue, _localctx._relExpr.retValue);
						}
						break;

					case 2:
						{
						_localctx = new EqExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_eqExpr);
						State = 127;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 128;
						_la = _input.La(1);
						if ( !(_la==T__28 || _la==T__6) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 129; _localctx._relExpr = relExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.NotEqual, _localctx.first.retValue, _localctx._relExpr.retValue);
						}
						break;
					}
					} 
				}
				State = 136;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class RelExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public RelExprContext first;
		public ShiftExprContext _shiftExpr;
		public RelExprContext relExpr() {
			return GetRuleContext<RelExprContext>(0);
		}
		public ShiftExprContext shiftExpr() {
			return GetRuleContext<ShiftExprContext>(0);
		}
		public RelExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relExpr; } }
	}

	[RuleVersion(0)]
	public RelExprContext relExpr() {
		return relExpr(0);
	}

	private RelExprContext relExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		RelExprContext _localctx = new RelExprContext(_ctx, _parentState);
		RelExprContext _prevctx = _localctx;
		int _startState = 16;
		EnterRecursionRule(_localctx, 16, RULE_relExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 138; _localctx._shiftExpr = shiftExpr(0);
			 _localctx.retValue =  _localctx._shiftExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 163;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,9,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 161;
					switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
					case 1:
						{
						_localctx = new RelExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_relExpr);
						State = 141;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 142; Match(T__13);
						State = 143; _localctx._shiftExpr = shiftExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Lesser, _localctx.first.retValue, _localctx._shiftExpr.retValue);
						}
						break;

					case 2:
						{
						_localctx = new RelExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_relExpr);
						State = 146;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 147; Match(T__20);
						State = 148; _localctx._shiftExpr = shiftExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.LesserOrEqual, _localctx.first.retValue, _localctx._shiftExpr.retValue);
						}
						break;

					case 3:
						{
						_localctx = new RelExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_relExpr);
						State = 151;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 152; Match(T__9);
						State = 153; _localctx._shiftExpr = shiftExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Greater, _localctx.first.retValue, _localctx._shiftExpr.retValue);
						}
						break;

					case 4:
						{
						_localctx = new RelExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_relExpr);
						State = 156;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 157; Match(T__14);
						State = 158; _localctx._shiftExpr = shiftExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.GreaterOrEqual, _localctx.first.retValue, _localctx._shiftExpr.retValue);
						}
						break;
					}
					} 
				}
				State = 165;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,9,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ShiftExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public ShiftExprContext first;
		public AddExprContext _addExpr;
		public AddExprContext addExpr() {
			return GetRuleContext<AddExprContext>(0);
		}
		public ShiftExprContext shiftExpr() {
			return GetRuleContext<ShiftExprContext>(0);
		}
		public ShiftExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shiftExpr; } }
	}

	[RuleVersion(0)]
	public ShiftExprContext shiftExpr() {
		return shiftExpr(0);
	}

	private ShiftExprContext shiftExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ShiftExprContext _localctx = new ShiftExprContext(_ctx, _parentState);
		ShiftExprContext _prevctx = _localctx;
		int _startState = 18;
		EnterRecursionRule(_localctx, 18, RULE_shiftExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 167; _localctx._addExpr = addExpr(0);
			 _localctx.retValue =  _localctx._addExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 182;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,11,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 180;
					switch ( Interpreter.AdaptivePredict(_input,10,_ctx) ) {
					case 1:
						{
						_localctx = new ShiftExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_shiftExpr);
						State = 170;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 171; Match(T__25);
						State = 172; _localctx._addExpr = addExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.LeftShift, _localctx.first.retValue, _localctx._addExpr.retValue);
						}
						break;

					case 2:
						{
						_localctx = new ShiftExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_shiftExpr);
						State = 175;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 176; Match(T__26);
						State = 177; _localctx._addExpr = addExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.RightShift, _localctx.first.retValue, _localctx._addExpr.retValue);
						}
						break;
					}
					} 
				}
				State = 184;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,11,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AddExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public AddExprContext first;
		public MultExprContext _multExpr;
		public AddExprContext addExpr() {
			return GetRuleContext<AddExprContext>(0);
		}
		public MultExprContext multExpr() {
			return GetRuleContext<MultExprContext>(0);
		}
		public AddExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_addExpr; } }
	}

	[RuleVersion(0)]
	public AddExprContext addExpr() {
		return addExpr(0);
	}

	private AddExprContext addExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		AddExprContext _localctx = new AddExprContext(_ctx, _parentState);
		AddExprContext _prevctx = _localctx;
		int _startState = 20;
		EnterRecursionRule(_localctx, 20, RULE_addExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 186; _localctx._multExpr = multExpr(0);
			 _localctx.retValue =  _localctx._multExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 201;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,13,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 199;
					switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
					case 1:
						{
						_localctx = new AddExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_addExpr);
						State = 189;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 190; Match(T__2);
						State = 191; _localctx._multExpr = multExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Plus, _localctx.first.retValue, _localctx._multExpr.retValue);
						}
						break;

					case 2:
						{
						_localctx = new AddExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_addExpr);
						State = 194;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 195; Match(T__0);
						State = 196; _localctx._multExpr = multExpr(0);
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Minus, _localctx.first.retValue, _localctx._multExpr.retValue);
						}
						break;
					}
					} 
				}
				State = 203;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,13,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MultExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public MultExprContext first;
		public UnaryExprContext _unaryExpr;
		public UnaryExprContext unaryExpr() {
			return GetRuleContext<UnaryExprContext>(0);
		}
		public MultExprContext multExpr() {
			return GetRuleContext<MultExprContext>(0);
		}
		public MultExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multExpr; } }
	}

	[RuleVersion(0)]
	public MultExprContext multExpr() {
		return multExpr(0);
	}

	private MultExprContext multExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		MultExprContext _localctx = new MultExprContext(_ctx, _parentState);
		MultExprContext _prevctx = _localctx;
		int _startState = 22;
		EnterRecursionRule(_localctx, 22, RULE_multExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 205; _localctx._unaryExpr = unaryExpr();
			 _localctx.retValue =  _localctx._unaryExpr.retValue;
			}
			_ctx.stop = _input.Lt(-1);
			State = 225;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,15,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 223;
					switch ( Interpreter.AdaptivePredict(_input,14,_ctx) ) {
					case 1:
						{
						_localctx = new MultExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_multExpr);
						State = 208;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 209; Match(T__17);
						State = 210; _localctx._unaryExpr = unaryExpr();
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Times, _localctx.first.retValue, _localctx._unaryExpr.retValue);
						}
						break;

					case 2:
						{
						_localctx = new MultExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_multExpr);
						State = 213;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 214; Match(T__29);
						State = 215; _localctx._unaryExpr = unaryExpr();
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Div, _localctx.first.retValue, _localctx._unaryExpr.retValue);
						}
						break;

					case 3:
						{
						_localctx = new MultExprContext(_parentctx, _parentState);
						_localctx.first = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_multExpr);
						State = 218;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 219; Match(T__5);
						State = 220; _localctx._unaryExpr = unaryExpr();
						 _localctx.retValue =  new BinaryExpression(BinaryExpressionType.Modulo, _localctx.first.retValue, _localctx._unaryExpr.retValue);
						}
						break;
					}
					} 
				}
				State = 227;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,15,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class UnaryExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public PrimaryExprContext _primaryExpr;
		public PrimaryExprContext primaryExpr() {
			return GetRuleContext<PrimaryExprContext>(0);
		}
		public UnaryExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpr; } }
	}

	[RuleVersion(0)]
	public UnaryExprContext unaryExpr() {
		UnaryExprContext _localctx = new UnaryExprContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_unaryExpr);
		int _la;
		try {
			State = 243;
			switch (_input.La(1)) {
			case T__7:
			case T__1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 228;
				_la = _input.La(1);
				if ( !(_la==T__7 || _la==T__1) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 229; _localctx._primaryExpr = primaryExpr();
				 _localctx.retValue =  new UnaryExpression(UnaryExpressionType.Not, _localctx._primaryExpr.retValue);
				}
				break;
			case T__10:
				EnterOuterAlt(_localctx, 2);
				{
				State = 232; Match(T__10);
				State = 233; _localctx._primaryExpr = primaryExpr();
				 _localctx.retValue =  new UnaryExpression(UnaryExpressionType.BitwiseNot, _localctx._primaryExpr.retValue);
				}
				break;
			case T__0:
				EnterOuterAlt(_localctx, 3);
				{
				State = 236; Match(T__0);
				State = 237; _localctx._primaryExpr = primaryExpr();
				 _localctx.retValue =  new UnaryExpression(UnaryExpressionType.Negate, _localctx._primaryExpr.retValue);
				}
				break;
			case T__18:
			case TRUE:
			case FALSE:
			case NAME:
			case INTEGER:
			case DATETIME:
			case VAR:
			case FLOAT:
			case STRING:
				EnterOuterAlt(_localctx, 4);
				{
				State = 240; _localctx._primaryExpr = primaryExpr();
				 _localctx.retValue =  _localctx._primaryExpr.retValue;
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimaryExprContext : ParserRuleContext {
		public LogicalExpression retValue;
		public ExprContext _expr;
		public ValueContext _value;
		public IdContext _id;
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public PrimaryExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryExpr; } }
	}

	[RuleVersion(0)]
	public PrimaryExprContext primaryExpr() {
		PrimaryExprContext _localctx = new PrimaryExprContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_primaryExpr);
		 var args = new List<LogicalExpression>(); 
		int _la;
		try {
			State = 272;
			switch ( Interpreter.AdaptivePredict(_input,18,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 245; Match(T__18);
				State = 246; _localctx._expr = expr();
				State = 247; Match(T__4);
				 _localctx.retValue =  _localctx._expr.retValue;
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 250; _localctx._value = value();
				 _localctx.retValue =  _localctx._value.retValue;
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 253; _localctx._id = id();
				State = 254; Match(T__18);
				State = 255; _localctx._expr = expr();
				 args.Add(_localctx._expr.retValue);
				State = 263;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==T__16) {
					{
					{
					State = 257; Match(T__16);
					State = 258; _localctx._expr = expr();
					 args.Add(_localctx._expr.retValue);
					}
					}
					State = 265;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 266; Match(T__4);
				 _localctx.retValue =  new FunctionExpression((IdentifierExpression)_localctx._id.retValue, args.ToArray());
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 269; _localctx._id = id();
				 _localctx.retValue =  _localctx._id.retValue;
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		public LogicalExpression retValue;
		public IToken _INTEGER;
		public IToken _FLOAT;
		public IToken _STRING;
		public IToken _DATETIME;
		public ITerminalNode INTEGER() { return GetToken(NCalc2Parser.INTEGER, 0); }
		public ITerminalNode DATETIME() { return GetToken(NCalc2Parser.DATETIME, 0); }
		public ITerminalNode FALSE() { return GetToken(NCalc2Parser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(NCalc2Parser.TRUE, 0); }
		public ITerminalNode STRING() { return GetToken(NCalc2Parser.STRING, 0); }
		public ITerminalNode FLOAT() { return GetToken(NCalc2Parser.FLOAT, 0); }
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_value);
		try {
			State = 286;
			switch (_input.La(1)) {
			case INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 274; _localctx._INTEGER = Match(INTEGER);
				 try{ _localctx.retValue =  new ValueExpression(int.Parse((_localctx._INTEGER!=null?_localctx._INTEGER.Text:null)), ValueType.Integer);} catch { _localctx.retValue =  new ValueExpression(long.Parse((_localctx._INTEGER!=null?_localctx._INTEGER.Text:null)), ValueType.Integer); } 
				}
				break;
			case FLOAT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 276; _localctx._FLOAT = Match(FLOAT);
				 _localctx.retValue =  new ValueExpression(double.Parse((_localctx._FLOAT!=null?_localctx._FLOAT.Text:null), NumberStyles.Float, numberFormatInfo), ValueType.Float);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 278; _localctx._STRING = Match(STRING);
				 _localctx.retValue =  new ValueExpression(extractString((_localctx._STRING!=null?_localctx._STRING.Text:null)), ValueType.String);
				}
				break;
			case DATETIME:
				EnterOuterAlt(_localctx, 4);
				{
				State = 280; _localctx._DATETIME = Match(DATETIME);
				 _localctx.retValue =  new ValueExpression(DateTime.Parse((_localctx._DATETIME!=null?_localctx._DATETIME.Text:null).Substring(1, (_localctx._DATETIME!=null?_localctx._DATETIME.Text:null).Length - 2)), ValueType.DateTime);
				}
				break;
			case TRUE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 282; Match(TRUE);
				 _localctx.retValue =  new ValueExpression(true, ValueType.Boolean);
				}
				break;
			case FALSE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 284; Match(FALSE);
				 _localctx.retValue =  new ValueExpression(false, ValueType.Boolean);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdContext : ParserRuleContext {
		public LogicalExpression retValue;
		public IToken _NAME;
		public IToken _VAR;
		public ITerminalNode VAR() { return GetToken(NCalc2Parser.VAR, 0); }
		public ITerminalNode NAME() { return GetToken(NCalc2Parser.NAME, 0); }
		public IdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id; } }
	}

	[RuleVersion(0)]
	public IdContext id() {
		IdContext _localctx = new IdContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_id);
		try {
			State = 292;
			switch (_input.La(1)) {
			case NAME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 288; _localctx._NAME = Match(NAME);
				 _localctx.retValue =  new IdentifierExpression((_localctx._NAME!=null?_localctx._NAME.Text:null)); 
				}
				break;
			case VAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 290; _localctx._VAR = Match(VAR);
				 _localctx.retValue =  new IdentifierExpression((_localctx._VAR!=null?_localctx._VAR.Text:null).Substring(1, (_localctx._VAR!=null?_localctx._VAR.Text:null).Length - 2)); 
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 2: return orExpr_sempred((OrExprContext)_localctx, predIndex);

		case 3: return andExpr_sempred((AndExprContext)_localctx, predIndex);

		case 4: return bitOrExpr_sempred((BitOrExprContext)_localctx, predIndex);

		case 5: return bitXorExpr_sempred((BitXorExprContext)_localctx, predIndex);

		case 6: return bitAndExpr_sempred((BitAndExprContext)_localctx, predIndex);

		case 7: return eqExpr_sempred((EqExprContext)_localctx, predIndex);

		case 8: return relExpr_sempred((RelExprContext)_localctx, predIndex);

		case 9: return shiftExpr_sempred((ShiftExprContext)_localctx, predIndex);

		case 10: return addExpr_sempred((AddExprContext)_localctx, predIndex);

		case 11: return multExpr_sempred((MultExprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool bitOrExpr_sempred(BitOrExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool eqExpr_sempred(EqExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(_ctx, 3);

		case 6: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool addExpr_sempred(AddExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 13: return Precpred(_ctx, 3);

		case 14: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool orExpr_sempred(OrExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool bitAndExpr_sempred(BitAndExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool relExpr_sempred(RelExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7: return Precpred(_ctx, 5);

		case 8: return Precpred(_ctx, 4);

		case 9: return Precpred(_ctx, 3);

		case 10: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool multExpr_sempred(MultExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(_ctx, 3);

		case 17: return Precpred(_ctx, 2);

		case 15: return Precpred(_ctx, 4);
		}
		return true;
	}
	private bool bitXorExpr_sempred(BitXorExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 3: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool andExpr_sempred(AndExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool shiftExpr_sempred(ShiftExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 11: return Precpred(_ctx, 3);

		case 12: return Precpred(_ctx, 2);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3*\x129\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x3\x2\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x5\x3\x31\n\x3\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4<\n\x4\f\x4\xE\x4?\v\x4\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\a\x5J\n\x5\f\x5\xE\x5M\v\x5"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\a\x6X\n\x6\f\x6"+
		"\xE\x6[\v\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\a\a\x66\n\a"+
		"\f\a\xE\ai\v\a\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\a\bt\n\b\f"+
		"\b\xE\bw\v\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3"+
		"\t\x3\t\x3\t\a\t\x87\n\t\f\t\xE\t\x8A\v\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3"+
		"\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3"+
		"\n\x3\n\x3\n\x3\n\x3\n\a\n\xA4\n\n\f\n\xE\n\xA7\v\n\x3\v\x3\v\x3\v\x3"+
		"\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\a\v\xB7\n\v\f\v\xE"+
		"\v\xBA\v\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\a\f\xCA\n\f\f\f\xE\f\xCD\v\f\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r"+
		"\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\a\r"+
		"\xE2\n\r\f\r\xE\r\xE5\v\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3"+
		"\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\xF6\n\xE\x3\xF\x3"+
		"\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF"+
		"\x3\xF\x3\xF\x3\xF\a\xF\x108\n\xF\f\xF\xE\xF\x10B\v\xF\x3\xF\x3\xF\x3"+
		"\xF\x3\xF\x3\xF\x3\xF\x5\xF\x113\n\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x5\x10\x121\n\x10\x3"+
		"\x11\x3\x11\x3\x11\x3\x11\x5\x11\x127\n\x11\x3\x11\x2\x2\f\x6\b\n\f\xE"+
		"\x10\x12\x14\x16\x18\x12\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2"+
		"\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\x2\a\x4\x2\x5\x5"+
		"\x18\x18\x4\x2\b\b\x1D\x1D\x4\x2\t\t\x14\x14\x4\x2\x4\x4\x1A\x1A\x4\x2"+
		"\x19\x19\x1F\x1F\x138\x2\"\x3\x2\x2\x2\x4\x30\x3\x2\x2\x2\x6\x32\x3\x2"+
		"\x2\x2\b@\x3\x2\x2\x2\nN\x3\x2\x2\x2\f\\\x3\x2\x2\x2\xEj\x3\x2\x2\x2\x10"+
		"x\x3\x2\x2\x2\x12\x8B\x3\x2\x2\x2\x14\xA8\x3\x2\x2\x2\x16\xBB\x3\x2\x2"+
		"\x2\x18\xCE\x3\x2\x2\x2\x1A\xF5\x3\x2\x2\x2\x1C\x112\x3\x2\x2\x2\x1E\x120"+
		"\x3\x2\x2\x2 \x126\x3\x2\x2\x2\"#\x5\x4\x3\x2#$\a\x2\x2\x3$%\b\x2\x1\x2"+
		"%\x3\x3\x2\x2\x2&\'\x5\x6\x4\x2\'(\a\v\x2\x2()\x5\x4\x3\x2)*\a\x11\x2"+
		"\x2*+\x5\x4\x3\x2+,\b\x3\x1\x2,\x31\x3\x2\x2\x2-.\x5\x6\x4\x2./\b\x3\x1"+
		"\x2/\x31\x3\x2\x2\x2\x30&\x3\x2\x2\x2\x30-\x3\x2\x2\x2\x31\x5\x3\x2\x2"+
		"\x2\x32\x33\b\x4\x1\x2\x33\x34\x5\b\x5\x2\x34\x35\b\x4\x1\x2\x35=\x3\x2"+
		"\x2\x2\x36\x37\f\x4\x2\x2\x37\x38\t\x2\x2\x2\x38\x39\x5\b\x5\x2\x39:\b"+
		"\x4\x1\x2:<\x3\x2\x2\x2;\x36\x3\x2\x2\x2<?\x3\x2\x2\x2=;\x3\x2\x2\x2="+
		">\x3\x2\x2\x2>\a\x3\x2\x2\x2?=\x3\x2\x2\x2@\x41\b\x5\x1\x2\x41\x42\x5"+
		"\n\x6\x2\x42\x43\b\x5\x1\x2\x43K\x3\x2\x2\x2\x44\x45\f\x4\x2\x2\x45\x46"+
		"\t\x3\x2\x2\x46G\x5\n\x6\x2GH\b\x5\x1\x2HJ\x3\x2\x2\x2I\x44\x3\x2\x2\x2"+
		"JM\x3\x2\x2\x2KI\x3\x2\x2\x2KL\x3\x2\x2\x2L\t\x3\x2\x2\x2MK\x3\x2\x2\x2"+
		"NO\b\x6\x1\x2OP\x5\f\a\x2PQ\b\x6\x1\x2QY\x3\x2\x2\x2RS\f\x4\x2\x2ST\a"+
		"\x15\x2\x2TU\x5\f\a\x2UV\b\x6\x1\x2VX\x3\x2\x2\x2WR\x3\x2\x2\x2X[\x3\x2"+
		"\x2\x2YW\x3\x2\x2\x2YZ\x3\x2\x2\x2Z\v\x3\x2\x2\x2[Y\x3\x2\x2\x2\\]\b\a"+
		"\x1\x2]^\x5\xE\b\x2^_\b\a\x1\x2_g\x3\x2\x2\x2`\x61\f\x4\x2\x2\x61\x62"+
		"\a\n\x2\x2\x62\x63\x5\xE\b\x2\x63\x64\b\a\x1\x2\x64\x66\x3\x2\x2\x2\x65"+
		"`\x3\x2\x2\x2\x66i\x3\x2\x2\x2g\x65\x3\x2\x2\x2gh\x3\x2\x2\x2h\r\x3\x2"+
		"\x2\x2ig\x3\x2\x2\x2jk\b\b\x1\x2kl\x5\x10\t\x2lm\b\b\x1\x2mu\x3\x2\x2"+
		"\x2no\f\x4\x2\x2op\a\r\x2\x2pq\x5\x10\t\x2qr\b\b\x1\x2rt\x3\x2\x2\x2s"+
		"n\x3\x2\x2\x2tw\x3\x2\x2\x2us\x3\x2\x2\x2uv\x3\x2\x2\x2v\xF\x3\x2\x2\x2"+
		"wu\x3\x2\x2\x2xy\b\t\x1\x2yz\x5\x12\n\x2z{\b\t\x1\x2{\x88\x3\x2\x2\x2"+
		"|}\f\x5\x2\x2}~\t\x4\x2\x2~\x7F\x5\x12\n\x2\x7F\x80\b\t\x1\x2\x80\x87"+
		"\x3\x2\x2\x2\x81\x82\f\x4\x2\x2\x82\x83\t\x5\x2\x2\x83\x84\x5\x12\n\x2"+
		"\x84\x85\b\t\x1\x2\x85\x87\x3\x2\x2\x2\x86|\x3\x2\x2\x2\x86\x81\x3\x2"+
		"\x2\x2\x87\x8A\x3\x2\x2\x2\x88\x86\x3\x2\x2\x2\x88\x89\x3\x2\x2\x2\x89"+
		"\x11\x3\x2\x2\x2\x8A\x88\x3\x2\x2\x2\x8B\x8C\b\n\x1\x2\x8C\x8D\x5\x14"+
		"\v\x2\x8D\x8E\b\n\x1\x2\x8E\xA5\x3\x2\x2\x2\x8F\x90\f\a\x2\x2\x90\x91"+
		"\a\x13\x2\x2\x91\x92\x5\x14\v\x2\x92\x93\b\n\x1\x2\x93\xA4\x3\x2\x2\x2"+
		"\x94\x95\f\x6\x2\x2\x95\x96\a\f\x2\x2\x96\x97\x5\x14\v\x2\x97\x98\b\n"+
		"\x1\x2\x98\xA4\x3\x2\x2\x2\x99\x9A\f\x5\x2\x2\x9A\x9B\a\x17\x2\x2\x9B"+
		"\x9C\x5\x14\v\x2\x9C\x9D\b\n\x1\x2\x9D\xA4\x3\x2\x2\x2\x9E\x9F\f\x4\x2"+
		"\x2\x9F\xA0\a\x12\x2\x2\xA0\xA1\x5\x14\v\x2\xA1\xA2\b\n\x1\x2\xA2\xA4"+
		"\x3\x2\x2\x2\xA3\x8F\x3\x2\x2\x2\xA3\x94\x3\x2\x2\x2\xA3\x99\x3\x2\x2"+
		"\x2\xA3\x9E\x3\x2\x2\x2\xA4\xA7\x3\x2\x2\x2\xA5\xA3\x3\x2\x2\x2\xA5\xA6"+
		"\x3\x2\x2\x2\xA6\x13\x3\x2\x2\x2\xA7\xA5\x3\x2\x2\x2\xA8\xA9\b\v\x1\x2"+
		"\xA9\xAA\x5\x16\f\x2\xAA\xAB\b\v\x1\x2\xAB\xB8\x3\x2\x2\x2\xAC\xAD\f\x5"+
		"\x2\x2\xAD\xAE\a\a\x2\x2\xAE\xAF\x5\x16\f\x2\xAF\xB0\b\v\x1\x2\xB0\xB7"+
		"\x3\x2\x2\x2\xB1\xB2\f\x4\x2\x2\xB2\xB3\a\x6\x2\x2\xB3\xB4\x5\x16\f\x2"+
		"\xB4\xB5\b\v\x1\x2\xB5\xB7\x3\x2\x2\x2\xB6\xAC\x3\x2\x2\x2\xB6\xB1\x3"+
		"\x2\x2\x2\xB7\xBA\x3\x2\x2\x2\xB8\xB6\x3\x2\x2\x2\xB8\xB9\x3\x2\x2\x2"+
		"\xB9\x15\x3\x2\x2\x2\xBA\xB8\x3\x2\x2\x2\xBB\xBC\b\f\x1\x2\xBC\xBD\x5"+
		"\x18\r\x2\xBD\xBE\b\f\x1\x2\xBE\xCB\x3\x2\x2\x2\xBF\xC0\f\x5\x2\x2\xC0"+
		"\xC1\a\x1E\x2\x2\xC1\xC2\x5\x18\r\x2\xC2\xC3\b\f\x1\x2\xC3\xCA\x3\x2\x2"+
		"\x2\xC4\xC5\f\x4\x2\x2\xC5\xC6\a \x2\x2\xC6\xC7\x5\x18\r\x2\xC7\xC8\b"+
		"\f\x1\x2\xC8\xCA\x3\x2\x2\x2\xC9\xBF\x3\x2\x2\x2\xC9\xC4\x3\x2\x2\x2\xCA"+
		"\xCD\x3\x2\x2\x2\xCB\xC9\x3\x2\x2\x2\xCB\xCC\x3\x2\x2\x2\xCC\x17\x3\x2"+
		"\x2\x2\xCD\xCB\x3\x2\x2\x2\xCE\xCF\b\r\x1\x2\xCF\xD0\x5\x1A\xE\x2\xD0"+
		"\xD1\b\r\x1\x2\xD1\xE3\x3\x2\x2\x2\xD2\xD3\f\x6\x2\x2\xD3\xD4\a\xF\x2"+
		"\x2\xD4\xD5\x5\x1A\xE\x2\xD5\xD6\b\r\x1\x2\xD6\xE2\x3\x2\x2\x2\xD7\xD8"+
		"\f\x5\x2\x2\xD8\xD9\a\x3\x2\x2\xD9\xDA\x5\x1A\xE\x2\xDA\xDB\b\r\x1\x2"+
		"\xDB\xE2\x3\x2\x2\x2\xDC\xDD\f\x4\x2\x2\xDD\xDE\a\x1B\x2\x2\xDE\xDF\x5"+
		"\x1A\xE\x2\xDF\xE0\b\r\x1\x2\xE0\xE2\x3\x2\x2\x2\xE1\xD2\x3\x2\x2\x2\xE1"+
		"\xD7\x3\x2\x2\x2\xE1\xDC\x3\x2\x2\x2\xE2\xE5\x3\x2\x2\x2\xE3\xE1\x3\x2"+
		"\x2\x2\xE3\xE4\x3\x2\x2\x2\xE4\x19\x3\x2\x2\x2\xE5\xE3\x3\x2\x2\x2\xE6"+
		"\xE7\t\x6\x2\x2\xE7\xE8\x5\x1C\xF\x2\xE8\xE9\b\xE\x1\x2\xE9\xF6\x3\x2"+
		"\x2\x2\xEA\xEB\a\x16\x2\x2\xEB\xEC\x5\x1C\xF\x2\xEC\xED\b\xE\x1\x2\xED"+
		"\xF6\x3\x2\x2\x2\xEE\xEF\a \x2\x2\xEF\xF0\x5\x1C\xF\x2\xF0\xF1\b\xE\x1"+
		"\x2\xF1\xF6\x3\x2\x2\x2\xF2\xF3\x5\x1C\xF\x2\xF3\xF4\b\xE\x1\x2\xF4\xF6"+
		"\x3\x2\x2\x2\xF5\xE6\x3\x2\x2\x2\xF5\xEA\x3\x2\x2\x2\xF5\xEE\x3\x2\x2"+
		"\x2\xF5\xF2\x3\x2\x2\x2\xF6\x1B\x3\x2\x2\x2\xF7\xF8\a\xE\x2\x2\xF8\xF9"+
		"\x5\x4\x3\x2\xF9\xFA\a\x1C\x2\x2\xFA\xFB\b\xF\x1\x2\xFB\x113\x3\x2\x2"+
		"\x2\xFC\xFD\x5\x1E\x10\x2\xFD\xFE\b\xF\x1\x2\xFE\x113\x3\x2\x2\x2\xFF"+
		"\x100\x5 \x11\x2\x100\x101\a\xE\x2\x2\x101\x102\x5\x4\x3\x2\x102\x109"+
		"\b\xF\x1\x2\x103\x104\a\x10\x2\x2\x104\x105\x5\x4\x3\x2\x105\x106\b\xF"+
		"\x1\x2\x106\x108\x3\x2\x2\x2\x107\x103\x3\x2\x2\x2\x108\x10B\x3\x2\x2"+
		"\x2\x109\x107\x3\x2\x2\x2\x109\x10A\x3\x2\x2\x2\x10A\x10C\x3\x2\x2\x2"+
		"\x10B\x109\x3\x2\x2\x2\x10C\x10D\a\x1C\x2\x2\x10D\x10E\b\xF\x1\x2\x10E"+
		"\x113\x3\x2\x2\x2\x10F\x110\x5 \x11\x2\x110\x111\b\xF\x1\x2\x111\x113"+
		"\x3\x2\x2\x2\x112\xF7\x3\x2\x2\x2\x112\xFC\x3\x2\x2\x2\x112\xFF\x3\x2"+
		"\x2\x2\x112\x10F\x3\x2\x2\x2\x113\x1D\x3\x2\x2\x2\x114\x115\a$\x2\x2\x115"+
		"\x121\b\x10\x1\x2\x116\x117\a(\x2\x2\x117\x121\b\x10\x1\x2\x118\x119\a"+
		")\x2\x2\x119\x121\b\x10\x1\x2\x11A\x11B\a%\x2\x2\x11B\x121\b\x10\x1\x2"+
		"\x11C\x11D\a!\x2\x2\x11D\x121\b\x10\x1\x2\x11E\x11F\a\"\x2\x2\x11F\x121"+
		"\b\x10\x1\x2\x120\x114\x3\x2\x2\x2\x120\x116\x3\x2\x2\x2\x120\x118\x3"+
		"\x2\x2\x2\x120\x11A\x3\x2\x2\x2\x120\x11C\x3\x2\x2\x2\x120\x11E\x3\x2"+
		"\x2\x2\x121\x1F\x3\x2\x2\x2\x122\x123\a#\x2\x2\x123\x127\b\x11\x1\x2\x124"+
		"\x125\a&\x2\x2\x125\x127\b\x11\x1\x2\x126\x122\x3\x2\x2\x2\x126\x124\x3"+
		"\x2\x2\x2\x127!\x3\x2\x2\x2\x17\x30=KYgu\x86\x88\xA3\xA5\xB6\xB8\xC9\xCB"+
		"\xE1\xE3\xF5\x109\x112\x120\x126";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace NCalc2.Grammar
